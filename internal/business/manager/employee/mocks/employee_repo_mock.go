// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.com/zigal0-group/nica/tango-api/internal/domain"
)

// EmployeeRepoMock implements employee_manager.employeeRepo
type EmployeeRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetByID          func(ctx context.Context, id int64) (e1 domain.Employee, err error)
	inspectFuncGetByID   func(ctx context.Context, id int64)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mEmployeeRepoMockGetByID

	funcInsert          func(ctx context.Context, employee domain.Employee) (i1 int64, err error)
	inspectFuncInsert   func(ctx context.Context, employee domain.Employee)
	afterInsertCounter  uint64
	beforeInsertCounter uint64
	InsertMock          mEmployeeRepoMockInsert
}

// NewEmployeeRepoMock returns a mock for employee_manager.employeeRepo
func NewEmployeeRepoMock(t minimock.Tester) *EmployeeRepoMock {
	m := &EmployeeRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetByIDMock = mEmployeeRepoMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*EmployeeRepoMockGetByIDParams{}

	m.InsertMock = mEmployeeRepoMockInsert{mock: m}
	m.InsertMock.callArgs = []*EmployeeRepoMockInsertParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mEmployeeRepoMockGetByID struct {
	mock               *EmployeeRepoMock
	defaultExpectation *EmployeeRepoMockGetByIDExpectation
	expectations       []*EmployeeRepoMockGetByIDExpectation

	callArgs []*EmployeeRepoMockGetByIDParams
	mutex    sync.RWMutex
}

// EmployeeRepoMockGetByIDExpectation specifies expectation struct of the employeeRepo.GetByID
type EmployeeRepoMockGetByIDExpectation struct {
	mock      *EmployeeRepoMock
	params    *EmployeeRepoMockGetByIDParams
	paramPtrs *EmployeeRepoMockGetByIDParamPtrs
	results   *EmployeeRepoMockGetByIDResults
	Counter   uint64
}

// EmployeeRepoMockGetByIDParams contains parameters of the employeeRepo.GetByID
type EmployeeRepoMockGetByIDParams struct {
	ctx context.Context
	id  int64
}

// EmployeeRepoMockGetByIDParamPtrs contains pointers to parameters of the employeeRepo.GetByID
type EmployeeRepoMockGetByIDParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// EmployeeRepoMockGetByIDResults contains results of the employeeRepo.GetByID
type EmployeeRepoMockGetByIDResults struct {
	e1  domain.Employee
	err error
}

// Expect sets up expected params for employeeRepo.GetByID
func (mmGetByID *mEmployeeRepoMockGetByID) Expect(ctx context.Context, id int64) *mEmployeeRepoMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("EmployeeRepoMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &EmployeeRepoMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.paramPtrs != nil {
		mmGetByID.mock.t.Fatalf("EmployeeRepoMock.GetByID mock is already set by ExpectParams functions")
	}

	mmGetByID.defaultExpectation.params = &EmployeeRepoMockGetByIDParams{ctx, id}
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// ExpectCtxParam1 sets up expected param ctx for employeeRepo.GetByID
func (mmGetByID *mEmployeeRepoMockGetByID) ExpectCtxParam1(ctx context.Context) *mEmployeeRepoMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("EmployeeRepoMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &EmployeeRepoMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("EmployeeRepoMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &EmployeeRepoMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetByID
}

// ExpectIdParam2 sets up expected param id for employeeRepo.GetByID
func (mmGetByID *mEmployeeRepoMockGetByID) ExpectIdParam2(id int64) *mEmployeeRepoMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("EmployeeRepoMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &EmployeeRepoMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("EmployeeRepoMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &EmployeeRepoMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.id = &id

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the employeeRepo.GetByID
func (mmGetByID *mEmployeeRepoMockGetByID) Inspect(f func(ctx context.Context, id int64)) *mEmployeeRepoMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for EmployeeRepoMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by employeeRepo.GetByID
func (mmGetByID *mEmployeeRepoMockGetByID) Return(e1 domain.Employee, err error) *EmployeeRepoMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("EmployeeRepoMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &EmployeeRepoMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &EmployeeRepoMockGetByIDResults{e1, err}
	return mmGetByID.mock
}

// Set uses given function f to mock the employeeRepo.GetByID method
func (mmGetByID *mEmployeeRepoMockGetByID) Set(f func(ctx context.Context, id int64) (e1 domain.Employee, err error)) *EmployeeRepoMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the employeeRepo.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the employeeRepo.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	return mmGetByID.mock
}

// When sets expectation for the employeeRepo.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mEmployeeRepoMockGetByID) When(ctx context.Context, id int64) *EmployeeRepoMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("EmployeeRepoMock.GetByID mock is already set by Set")
	}

	expectation := &EmployeeRepoMockGetByIDExpectation{
		mock:   mmGetByID.mock,
		params: &EmployeeRepoMockGetByIDParams{ctx, id},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up employeeRepo.GetByID return parameters for the expectation previously defined by the When method
func (e *EmployeeRepoMockGetByIDExpectation) Then(e1 domain.Employee, err error) *EmployeeRepoMock {
	e.results = &EmployeeRepoMockGetByIDResults{e1, err}
	return e.mock
}

// GetByID implements employee_manager.employeeRepo
func (mmGetByID *EmployeeRepoMock) GetByID(ctx context.Context, id int64) (e1 domain.Employee, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, id)
	}

	mm_params := EmployeeRepoMockGetByIDParams{ctx, id}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, &mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByID.GetByIDMock.defaultExpectation.paramPtrs

		mm_got := EmployeeRepoMockGetByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByID.t.Errorf("EmployeeRepoMock.GetByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetByID.t.Errorf("EmployeeRepoMock.GetByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("EmployeeRepoMock.GetByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the EmployeeRepoMock.GetByID")
		}
		return (*mm_results).e1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, id)
	}
	mmGetByID.t.Fatalf("Unexpected call to EmployeeRepoMock.GetByID. %v %v", ctx, id)
	return
}

// GetByIDAfterCounter returns a count of finished EmployeeRepoMock.GetByID invocations
func (mmGetByID *EmployeeRepoMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of EmployeeRepoMock.GetByID invocations
func (mmGetByID *EmployeeRepoMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepoMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mEmployeeRepoMockGetByID) Calls() []*EmployeeRepoMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*EmployeeRepoMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *EmployeeRepoMock) MinimockGetByIDDone() bool {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *EmployeeRepoMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepoMock.GetByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepoMock.GetByID")
		} else {
			m.t.Errorf("Expected call to EmployeeRepoMock.GetByID with params: %#v", *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepoMock.GetByID")
	}
}

type mEmployeeRepoMockInsert struct {
	mock               *EmployeeRepoMock
	defaultExpectation *EmployeeRepoMockInsertExpectation
	expectations       []*EmployeeRepoMockInsertExpectation

	callArgs []*EmployeeRepoMockInsertParams
	mutex    sync.RWMutex
}

// EmployeeRepoMockInsertExpectation specifies expectation struct of the employeeRepo.Insert
type EmployeeRepoMockInsertExpectation struct {
	mock      *EmployeeRepoMock
	params    *EmployeeRepoMockInsertParams
	paramPtrs *EmployeeRepoMockInsertParamPtrs
	results   *EmployeeRepoMockInsertResults
	Counter   uint64
}

// EmployeeRepoMockInsertParams contains parameters of the employeeRepo.Insert
type EmployeeRepoMockInsertParams struct {
	ctx      context.Context
	employee domain.Employee
}

// EmployeeRepoMockInsertParamPtrs contains pointers to parameters of the employeeRepo.Insert
type EmployeeRepoMockInsertParamPtrs struct {
	ctx      *context.Context
	employee *domain.Employee
}

// EmployeeRepoMockInsertResults contains results of the employeeRepo.Insert
type EmployeeRepoMockInsertResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for employeeRepo.Insert
func (mmInsert *mEmployeeRepoMockInsert) Expect(ctx context.Context, employee domain.Employee) *mEmployeeRepoMockInsert {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("EmployeeRepoMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &EmployeeRepoMockInsertExpectation{}
	}

	if mmInsert.defaultExpectation.paramPtrs != nil {
		mmInsert.mock.t.Fatalf("EmployeeRepoMock.Insert mock is already set by ExpectParams functions")
	}

	mmInsert.defaultExpectation.params = &EmployeeRepoMockInsertParams{ctx, employee}
	for _, e := range mmInsert.expectations {
		if minimock.Equal(e.params, mmInsert.defaultExpectation.params) {
			mmInsert.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsert.defaultExpectation.params)
		}
	}

	return mmInsert
}

// ExpectCtxParam1 sets up expected param ctx for employeeRepo.Insert
func (mmInsert *mEmployeeRepoMockInsert) ExpectCtxParam1(ctx context.Context) *mEmployeeRepoMockInsert {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("EmployeeRepoMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &EmployeeRepoMockInsertExpectation{}
	}

	if mmInsert.defaultExpectation.params != nil {
		mmInsert.mock.t.Fatalf("EmployeeRepoMock.Insert mock is already set by Expect")
	}

	if mmInsert.defaultExpectation.paramPtrs == nil {
		mmInsert.defaultExpectation.paramPtrs = &EmployeeRepoMockInsertParamPtrs{}
	}
	mmInsert.defaultExpectation.paramPtrs.ctx = &ctx

	return mmInsert
}

// ExpectEmployeeParam2 sets up expected param employee for employeeRepo.Insert
func (mmInsert *mEmployeeRepoMockInsert) ExpectEmployeeParam2(employee domain.Employee) *mEmployeeRepoMockInsert {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("EmployeeRepoMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &EmployeeRepoMockInsertExpectation{}
	}

	if mmInsert.defaultExpectation.params != nil {
		mmInsert.mock.t.Fatalf("EmployeeRepoMock.Insert mock is already set by Expect")
	}

	if mmInsert.defaultExpectation.paramPtrs == nil {
		mmInsert.defaultExpectation.paramPtrs = &EmployeeRepoMockInsertParamPtrs{}
	}
	mmInsert.defaultExpectation.paramPtrs.employee = &employee

	return mmInsert
}

// Inspect accepts an inspector function that has same arguments as the employeeRepo.Insert
func (mmInsert *mEmployeeRepoMockInsert) Inspect(f func(ctx context.Context, employee domain.Employee)) *mEmployeeRepoMockInsert {
	if mmInsert.mock.inspectFuncInsert != nil {
		mmInsert.mock.t.Fatalf("Inspect function is already set for EmployeeRepoMock.Insert")
	}

	mmInsert.mock.inspectFuncInsert = f

	return mmInsert
}

// Return sets up results that will be returned by employeeRepo.Insert
func (mmInsert *mEmployeeRepoMockInsert) Return(i1 int64, err error) *EmployeeRepoMock {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("EmployeeRepoMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &EmployeeRepoMockInsertExpectation{mock: mmInsert.mock}
	}
	mmInsert.defaultExpectation.results = &EmployeeRepoMockInsertResults{i1, err}
	return mmInsert.mock
}

// Set uses given function f to mock the employeeRepo.Insert method
func (mmInsert *mEmployeeRepoMockInsert) Set(f func(ctx context.Context, employee domain.Employee) (i1 int64, err error)) *EmployeeRepoMock {
	if mmInsert.defaultExpectation != nil {
		mmInsert.mock.t.Fatalf("Default expectation is already set for the employeeRepo.Insert method")
	}

	if len(mmInsert.expectations) > 0 {
		mmInsert.mock.t.Fatalf("Some expectations are already set for the employeeRepo.Insert method")
	}

	mmInsert.mock.funcInsert = f
	return mmInsert.mock
}

// When sets expectation for the employeeRepo.Insert which will trigger the result defined by the following
// Then helper
func (mmInsert *mEmployeeRepoMockInsert) When(ctx context.Context, employee domain.Employee) *EmployeeRepoMockInsertExpectation {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("EmployeeRepoMock.Insert mock is already set by Set")
	}

	expectation := &EmployeeRepoMockInsertExpectation{
		mock:   mmInsert.mock,
		params: &EmployeeRepoMockInsertParams{ctx, employee},
	}
	mmInsert.expectations = append(mmInsert.expectations, expectation)
	return expectation
}

// Then sets up employeeRepo.Insert return parameters for the expectation previously defined by the When method
func (e *EmployeeRepoMockInsertExpectation) Then(i1 int64, err error) *EmployeeRepoMock {
	e.results = &EmployeeRepoMockInsertResults{i1, err}
	return e.mock
}

// Insert implements employee_manager.employeeRepo
func (mmInsert *EmployeeRepoMock) Insert(ctx context.Context, employee domain.Employee) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmInsert.beforeInsertCounter, 1)
	defer mm_atomic.AddUint64(&mmInsert.afterInsertCounter, 1)

	if mmInsert.inspectFuncInsert != nil {
		mmInsert.inspectFuncInsert(ctx, employee)
	}

	mm_params := EmployeeRepoMockInsertParams{ctx, employee}

	// Record call args
	mmInsert.InsertMock.mutex.Lock()
	mmInsert.InsertMock.callArgs = append(mmInsert.InsertMock.callArgs, &mm_params)
	mmInsert.InsertMock.mutex.Unlock()

	for _, e := range mmInsert.InsertMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmInsert.InsertMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsert.InsertMock.defaultExpectation.Counter, 1)
		mm_want := mmInsert.InsertMock.defaultExpectation.params
		mm_want_ptrs := mmInsert.InsertMock.defaultExpectation.paramPtrs

		mm_got := EmployeeRepoMockInsertParams{ctx, employee}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsert.t.Errorf("EmployeeRepoMock.Insert got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.employee != nil && !minimock.Equal(*mm_want_ptrs.employee, mm_got.employee) {
				mmInsert.t.Errorf("EmployeeRepoMock.Insert got unexpected parameter employee, want: %#v, got: %#v%s\n", *mm_want_ptrs.employee, mm_got.employee, minimock.Diff(*mm_want_ptrs.employee, mm_got.employee))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsert.t.Errorf("EmployeeRepoMock.Insert got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsert.InsertMock.defaultExpectation.results
		if mm_results == nil {
			mmInsert.t.Fatal("No results are set for the EmployeeRepoMock.Insert")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmInsert.funcInsert != nil {
		return mmInsert.funcInsert(ctx, employee)
	}
	mmInsert.t.Fatalf("Unexpected call to EmployeeRepoMock.Insert. %v %v", ctx, employee)
	return
}

// InsertAfterCounter returns a count of finished EmployeeRepoMock.Insert invocations
func (mmInsert *EmployeeRepoMock) InsertAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsert.afterInsertCounter)
}

// InsertBeforeCounter returns a count of EmployeeRepoMock.Insert invocations
func (mmInsert *EmployeeRepoMock) InsertBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsert.beforeInsertCounter)
}

// Calls returns a list of arguments used in each call to EmployeeRepoMock.Insert.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsert *mEmployeeRepoMockInsert) Calls() []*EmployeeRepoMockInsertParams {
	mmInsert.mutex.RLock()

	argCopy := make([]*EmployeeRepoMockInsertParams, len(mmInsert.callArgs))
	copy(argCopy, mmInsert.callArgs)

	mmInsert.mutex.RUnlock()

	return argCopy
}

// MinimockInsertDone returns true if the count of the Insert invocations corresponds
// the number of defined expectations
func (m *EmployeeRepoMock) MinimockInsertDone() bool {
	for _, e := range m.InsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsert != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertInspect logs each unmet expectation
func (m *EmployeeRepoMock) MinimockInsertInspect() {
	for _, e := range m.InsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmployeeRepoMock.Insert with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		if m.InsertMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmployeeRepoMock.Insert")
		} else {
			m.t.Errorf("Expected call to EmployeeRepoMock.Insert with params: %#v", *m.InsertMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsert != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		m.t.Error("Expected call to EmployeeRepoMock.Insert")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EmployeeRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetByIDInspect()

			m.MinimockInsertInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EmployeeRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EmployeeRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetByIDDone() &&
		m.MinimockInsertDone()
}
